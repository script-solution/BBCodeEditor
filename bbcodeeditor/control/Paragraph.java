/**
 * Copyright (C) 2004 - 2012 Nils Asmussen
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

package bbcodeeditor.control;

import java.util.*;

import bbcodeeditor.control.actions.SetAttributeActionPart;
import bbcodeeditor.control.tools.MutablePointer;
import bbcodeeditor.control.tools.MyLinkedList;
import bbcodeeditor.control.view.ILineView;
import bbcodeeditor.control.view.IParagraphView;
import bbcodeeditor.control.view.ParagraphView;


/**
 * A paragraph contains at least one line but may contain multiple lines.
 * <p>
 * These lines are generated by wordwrap. That means that there are no new-lines but the
 * lines are directly together. They are just painted on different lines.<br>
 * So the positions don't change if you move sections from line to line!
 * <p>
 * An Environment has a ParagraphContainer which contains multiple paragraphs. After
 * each paragraph follows a new-line.<br>
 * A paragraph, or lets better say a line, may contain an environment. If so there is no
 * other content. In this case the paragraph has just one line and the line just one
 * section: the environment.
 * <p>
 * A paragraph may have a different alignment like ALIGN_CENTER or ALIGN_RIGHT.<br>
 * Additionally you can specify if a paragraph is a list-point (in list-environments) or
 * not.<br>
 * All paragraphs have a height which you can read.
 * <p>
 * Paragraphs are "closed-systems". That means that the first line starts with position 0.
 * Therefore all methods in this class should get the position IN this paragraph.
 * 
 * @author hrniels
 */
public final class Paragraph extends PositionElement {

	/**
	 * a linked list with all lines of this container
	 * 
	 * Note that we init it with 2 entries because in most cases we won't
	 * have more than 2 lines.
	 */
	private final MyLinkedList _lines = new MyLinkedList(2);
	
	/**
	 * The highlighter for this paragraph
	 */
	private final ParagraphHighlighter _highlighter;
	
	/**
	 * the alignment of the text in this line
	 * 
	 * @see ParagraphAttributes
	 */
	private int _align = ParagraphAttributes.ALIGN_LEFT;
	
	/**
	 * indicates if this line is a new list-point
	 * (will only be used in list-environments)
	 */
	private boolean _isListPoint = true;
	
	/**
	 * indicates wether this paragraph contains an environment
	 */
	private boolean _containsEnv = false;
	
	/**
	 * constructor
	 * 
	 * @param parentEnv the environment which contains this paragraph
	 * @param startPos the "global" start-position
	 * @param endPos the "global" end-position
	 */
	Paragraph(Environment parentEnv,int startPos,int endPos) {
		super(parentEnv,startPos,endPos);
		
		_view = new ParagraphView(this);
		
		// at least 1 line is required
		_lines.add(new Line(parentEnv,this));
		
		if(_env instanceof CodeEnvironment)
			_highlighter = new ParagraphHighlighter(this);
		else
			_highlighter = null;
	}
	
	/**
	 * @return the IParagraphView-implementation
	 */
	public IParagraphView getParagraphView() {
		return (IParagraphView)_view;
	}
	
	/**
	 * @return the ParagraphHighlighter instance for this paragraph
	 */
	ParagraphHighlighter getHighlighter() {
		return _highlighter;
	}
	
	/**
	 * @return wether this paragraph contains an environment
	 */
	public boolean containsEnvironment() {
		return _containsEnv;
	}
	
	/**
	 * this will be used for list-environments to support multiple lines for one list-point
	 * 
	 * @return wether this line is a new list-point
	 */
	public boolean isListPoint() {
		return _isListPoint;
	}
	
	/**
	 * sets wether this line is a new list-point
	 * 
	 * @param isListPoint is it a new list point?
	 */
	void setListPoint(boolean isListPoint) {
		_isListPoint = isListPoint;
	}
	
	/**
	 * @return the horizontal alignment of this line (ALIGN_LEFT,ALIGN_CENTER,ALIGN_RIGHT)
	 * @see ParagraphAttributes
	 */
	public int getHorizontalAlignment() {
		return _align;
	}
	
	/**
	 * sets the horizontal alignment
	 * 
	 * @param align the new value
	 * @return true if the alignment has been changed
	 * @see ParagraphAttributes
	 */
	boolean setHorizontalAlignment(int align) {
		boolean res = _align != align;
		_align = align;
		
		// we have to refresh the paint-positions in this paragraph
		if(res)
			getTextField().getPaintPosManager().addParagraph(this);
		
		return res;
	}

	/**
	 * resets this container
	 */
	void clear() {
		_lines.clear();
		
		_lines.add(new Line(_env,this));
	}
	
	/**
	 * collects the text of this paragraph (without formating)
	 * 
	 * @return the text in this paragraph
	 */
	public String getText() {
		StringBuffer text = new StringBuffer();
		Section s = getFirstSection();
		do {
			if(s instanceof TextSection)
				text.append(((TextSection)s).getText());
			else if(s instanceof ImageSection)
				text.append(ImageSection.dummyText);
			
			s = s.getNextInParagraph();
		} while(s != null);
		
		return text.toString();
	}
	
	/**
	 * collects all attributes in the given interval.<br>
	 * Attributes which have in the whole interval the same value will
	 * have this value in the map. Attributes which change in the interval
	 * will be in the map but have a null-value.<br>
	 * Other attributes will not be in the map
	 * 
	 * @param start the start-position in this paragraph
	 * @param end the end-position in this paragraph
	 * @param attributes the map which will be collected
	 */
	void collectAttributes(int start,int end,MutablePointer attributes) {
		Section s = getFirstSection();
		
		// do we have an environment?
		if(s instanceof Environment) {
			Environment es = (Environment)s;
			es.collectAttributes(start,end,attributes);
			return;
		}
		
		while(s != null) {
			// do we "hit" this section?
			if(hitSectionWithAttribute(s,start,end)) {
				if(s instanceof TextSection) {
					TextSection ts = (TextSection)s;
					
					if(attributes.getValue() == null)
						attributes.setValue(ts.getCloneOfAttributes());
					else {
						TextAttributes mAttr = (TextAttributes)attributes.getValue();
						TextAttributes tsAttr = ts.getAttributes();
						
						// add / disable attributes, if necessary
						Iterator it = tsAttr.iterator();
						while(it.hasNext()) {
							Integer attr = (Integer)it.next();
							
							Object attrVal = mAttr.get(attr);
							Object tsAttrVal = tsAttr.get(attr);
							boolean equal = TextAttributes.compareAttribute(_env,attr,attrVal,tsAttrVal);
							if(!equal && attrVal == null)
								mAttr.remove(attr);
							else if(!equal)
								mAttr.set(attr,tsAttrVal);
						}
						
						// disable attributes, if necessary
						it = mAttr.iterator();
						while(it.hasNext()) {
							Integer attr = (Integer)it.next();
							
							if(!tsAttr.isSet(attr))
								mAttr.remove(attr);
						}
					}
				}
			}
			
			// are we finished?
			if(end <= s.getElementEndPos() + 1)
				break;
			
			s = s.getNextInParagraph();
		}
	}
	
	/**
	 * collects all attribute-regions in the given interval
	 * will return an ArrayList with all found regions
	 * 
	 * @param start the start-position in this paragraph
	 * @param end the end-position in this paragraph
	 * @param attributes a List with all attributes to check
	 * @return a List with all found regions
	 */
	List getAttributeRegions(int start,int end,List attributes) {
		Section s = getFirstSection();
		
		// do we have an environment?
		if(s instanceof Environment) {
			Environment es = (Environment)s;
			return es.getAttributeRegions(start,end,attributes);
		}
		
		int envStart = _env.getGlobalStartPos() + getElementStartPos();
		ArrayList regions = new ArrayList();
		TextAttributes last = null;
		boolean added = false;
		boolean foundFirst = false;
		int regionStart = Math.max(s.getElementStartPos(),start);
		
		// ok, loop through all sections in this line
		while(s != null) {
			// do we "hit" this section?
			if(hitSectionWithAttribute(s,start,end)) {
				if(s instanceof TextSection) {
					TextSection ts = (TextSection)s;

					// do we have to add a new region?
					boolean newRegion = !foundFirst;
					TextAttributes thisAttr = TextAttributes.getCloneWith(ts.getAttributes(),attributes);
					if(!newRegion) {
						boolean equal = TextAttributes.compareAttributes(_env,last,thisAttr);
						newRegion = !equal;
					}
					
					// add new region?
					if(newRegion) {
						// don't add the first found region
						if(foundFirst) {
							int regionEnd = Math.min(s.getElementStartPos(),end);
							SetAttributeActionPart action = new SetAttributeActionPart(regionStart + envStart,
									regionEnd + envStart,last);
							regions.add(action);
	
							// set next region-start to the current end-pos
							regionStart = regionEnd;
							added = true;
						}
						
						last = thisAttr;
						foundFirst = true;
					}
				}
			}
			else
				regionStart = Math.max(s.getElementStartPos(),start);
			
			// are we finished?
			if(end <= s.getElementEndPos() + 1)
				break;
			
			s = s.getNextInParagraph();
		}
		
		// add the last region if not already done
		Section lastSec = s != null ? s : getLastSection();
		if((!added && lastSec.getElementLength() == 0) ||
				regionStart != lastSec.getElementEndPos() + 1) {
			regionStart = Math.max(regionStart,start);
			// just add textsections
			if(regionStart != lastSec.getElementStartPos() || lastSec instanceof TextSection) {
				int regionEnd = Math.min(lastSec.getElementEndPos() + 1,end);
				SetAttributeActionPart action = new SetAttributeActionPart(regionStart + envStart,
						regionEnd + envStart,last);
				regions.add(action);
			}
		}
		
		return regions;
	}

	/**
	 * Applies the given attribute to the given interval. This will always
	 * all the attributes!
	 * Note that this method does <b>NOT</b> refresh the font!
	 * 
	 * @param start the start-position in this paragraph
	 * @param end the end-position in this paragraph
	 * @param attributes a SortedHashtable with all attributes to apply
	 * 				null-values will remove an attribute
	 * @param replace replace the attributes in the sections?
	 * @return true if something has been changed
	 */
	boolean applyAttributes(int start,int end,TextAttributes attributes,boolean replace) {
		return applyAttributes(start,end,attributes,replace,true,false);
	}
	
	/**
	 * applies the given attribute to the given interval.
	 * Note that <code>refreshFont</code> doesn't have an effect if <code>replace</code>
	 * is disabled!
	 * 
	 * @param start the start-position in this paragraph
	 * @param end the end-position in this paragraph
	 * @param attributes a SortedHashtable with all attributes to apply
	 * 				null-values will remove an attribute
	 * @param replace replace the attributes in the sections?
	 * @param allowAll if true the attributes will be set in envs that contain
	 * 				no styles, too
	 * @param refreshFont refresh the font in the sections? (mark for refresh)
	 * @return true if something has been changed
	 */
	boolean applyAttributes(int start,int end,TextAttributes attributes,
			boolean replace,boolean allowAll,boolean refreshFont) {
		Section s = getFirstSection();
		
		// do we have an environment?
		if(s instanceof Environment) {
			Environment es = (Environment)s;
			return es.applyAttributes(start,end,attributes,replace,allowAll);
		}
		
		boolean changed = false;
		
		// ok, loop through all sections in this line
		while(s != null) {
			// do we "hit" this section?
			if(hitSectionWithAttribute(s,start,end)) {
				if(s instanceof TextSection) {
					Line l = s.getSectionLine();
					TextSection ts = (TextSection)s;
					
					// do we want to apply the attribute to the whole section?
					if(start <= s.getElementStartPos() && end > s.getElementEndPos()) {
						if(replace) {
							ts.setAttributeRange(attributes,refreshFont);
							changed = true;
						}
						else {
							if(ts.setAttributes(attributes))
								changed = true;
						}
					}
					// apply attributes to empty sections
					else if(end == s.getElementStartPos() && s.getElementLength() == 0) {
						if(replace) {
							ts.setAttributeRange(attributes,refreshFont);
							changed = true;
						}
						else {
							if(ts.setAttributes(attributes))
								changed = true;
						}
					}
					// just do this if we want to change anything IN the section
					else if(end > s.getElementStartPos()) {
						int endPos = s.getElementEndPos();
						int startPos = s.getElementStartPos();
						
						// split at the start pos
						Section split = null;
						if(start > startPos) {
							split = l.ensureNewSection(start,refreshFont);
							// do we have to use the first section in the line?
							if(split == null)
								split = getFirstSection();
						}
						
						// split at the end-pos
						if(end <= endPos) {
							split = l.ensureNewSection(end,refreshFont);
							// do we have to use the first section in the line?
							if(split == null)
								split = getFirstSection();
						}
						
						// determine section to apply the attribute to
						Section attrSec = null;
						if(end <= endPos)
							attrSec = split;
						else
							attrSec = (Section)split.getNext();
						
						// apply attribute
						if(attrSec instanceof TextSection) {
							if(replace) {
								((TextSection)attrSec).setAttributeRange(attributes,refreshFont);
								changed = true;
							}
							else {
								if(((TextSection)attrSec).setAttributes(attributes))
									changed = true;
							}
						}
					}
				}
			}
			
			// are we finished?
			if(end <= s.getElementEndPos() + 1)
				break;
			
			s = s.getNextInParagraph();
		}
		
		return changed;
	}
	
	/**
	 * determines wether the given section will be hit by the given interval
	 * 
	 * @param sec the section
	 * @param start the start-position of the interval
	 * @param end the end-position of the interval
	 * @return true if the section will be hit
	 */
	private boolean hitSectionWithAttribute(Section sec,int start,int end) {
		if(start < sec.getElementEndPos() + 1 && end >= sec.getElementStartPos())
			return true;
		
		// hit empty section
		return start == sec.getElementEndPos() + 1 && sec.getElementLength() == 0;
	}
	
	/**
	 * moves all sections of the given line to the previous one
	 * and moves all following lines one upwards
	 * 
	 * @param l the line to move
	 */
	void moveToPrevLine(Line l) {
		Line prev = (Line)l.getPrev();
		if(prev == null)
			return;
		
		Section s = l.getFirstSection();
		if(s.getElementLength() > 0) {
			// we can't use the getNext() method here, because the sections
			// will be moved to another line, so that the pointer will be changed
			int i = 0;
			int len = l.getSectionCount();
			do {
				s.setSectionLine(prev);
				prev.addSection(s);
				
				// go to next section
				i++;
				if(i < len)
					s = l.getSection(i);
			} while(i < len);
		}
		
		// remove the line
		_lines.remove(l);
	}
	
	/**
	 * adds the text in the given line from the start to the given position to
	 * the previous line<br>
	 * This will be used by the wordwrap-function!
	 * 
	 * @param line the line
	 * @param cursorPos the position where to split
	 * @return the current section
	 */
	ContentSection addToPrevLine(Line line,int cursorPos) {
		// should never happen, but just to be sure
		if(line.isFirst())
			return null;
		
		Section[] sections = line.moveToNewLine(cursorPos,false);
		Line prevLine = (Line)line.getPrev();
		
		ContentSection lastInLine = (ContentSection)prevLine.getLastSection();
		for(int i = sections.length - 1;i >= 0;i--) {
			// determine if we can add the section to the last one of the line
			boolean addToSec = false;
			if(lastInLine instanceof TextSection && sections[i] instanceof TextSection) {
				TextSection tLastInLine = (TextSection)lastInLine;
				TextSection tSec = (TextSection)sections[i];
				if(TextAttributes.compareAttributes(_env,tLastInLine.getAttributes(),tSec.getAttributes()))
					addToSec = true;
			}
			
			if(addToSec) {
				TextSection tLastInLine = (TextSection)lastInLine;
				TextSection tSec = (TextSection)sections[i];
				tLastInLine.addTextAt(tSec.getText(),tLastInLine.getElementLength(),true);
			}
			else {
				sections[i].setSectionLine(prevLine);
				prevLine.addSection(sections[i]);
				lastInLine = (ContentSection)sections[i];
			}
		}
		
		return (ContentSection)prevLine.getLastSection();
	}
	
	/**
	 * adds the text in the given line beginning at the given position to the next line<br>
	 * This will be used by the wordwrap-function!
	 * 
	 * @param line the line
	 * @param cursorPos the position where to split (in this paragraph)
	 * @return the current section
	 */
	ContentSection addToNextLine(Line line,int cursorPos) {
		// should never happen, but just to be sure
		if(line.isLast())
			return null;
		
		Section[] sections = line.moveToNewLine(cursorPos,true);
		Line nextLine = (Line)line.getNext();
		
		ContentSection firstInLine = (ContentSection)nextLine.getFirstSection();
		for(int i = sections.length - 1;i >= 0;i--) {
			// determine if we can add the section to the first one of the line
			boolean addToSec = false;
			if(firstInLine instanceof TextSection && sections[i] instanceof TextSection) {
				TextSection tFirstInLine = (TextSection)firstInLine;
				TextSection tSec = (TextSection)sections[i];
				if(TextAttributes.compareAttributes(_env,tFirstInLine.getAttributes(),tSec.getAttributes()))
					addToSec = true;
			}
			
			if(addToSec) {
				TextSection tFirstInLine = (TextSection)firstInLine;
				TextSection tSec = (TextSection)sections[i];
				tFirstInLine.addTextAt(tSec.getText(),0,true);
				tFirstInLine.decreaseElementPos(tSec.getElementLength());
			}
			else {
				sections[i].setSectionLine(nextLine);
				nextLine.addSection(0,sections[i]);
				firstInLine = (ContentSection)sections[i];
			}
		}
		
		return (ContentSection)nextLine.getFirstSection();
	}
	
	/**
	 * adds the given section to the end of this paragraph<br>
	 * Will not adjust any positions but will set the section-line and paragraph
	 * 
	 * @param s the section to add
	 */
	void addSection(Section s) {
		Line l = getLastLine();
		s.setSectionLine(l);
		s.setSectionParagraph(this);
		l.addSection(s);
	}
	
	/**
	 * collects all sections starting at the given position which should
	 * be moved to a new paragraph<br>
	 * If necessary the section at the position will be splitted<br>
	 * This method will remove the sections from this paragraph, too<br>
	 * The position of this paragraph will be adjusted!
	 * 
	 * @param position the position where to start collecting (in this paragraph!)
	 * @return a list with all ContentSections to move
	 */
	List getSectionsForNewParagraph(int position) {
		Line l = getLineAtPosition(position);
		ContentSection s = l.ensureNewSection(position);
		
		if(s == null)
			s = (ContentSection)getFirstSection();
		else
			s = (ContentSection)s.getNextInParagraph();
		
		int len = 0;
		List sections = new ArrayList();
		while(s != null) {
			Line line = s.getSectionLine();
			len += s.getElementLength();
			sections.add(s);
			line.removeSection(s);
			
			if(line.getLineLength() == 0 && _lines.size() > 1)
				remove(line);
			
			s = (ContentSection)s.getNextInParagraph();
		}
		
		decreaseElementEndPos(len);
		
		return sections;
	}

	/**
	 * moves all sections beginning at cursorPos to the next line
	 * 
	 * @param cursorPos the position of the cursor
	 * @return the new section of the cursor
	 */
	ContentSection moveToNextLine(int cursorPos) {
		Line l = getLineAtPosition(cursorPos);
		return moveToNextLine(l,cursorPos);
	}

	/**
	 * moves all sections beginning at cursorPos to the next line
	 *
	 * @param line the line of the given cursor-position
	 * @param cursorPos the position of the cursor
	 * @return the new section of the cursor
	 */
	ContentSection moveToNextLine(Line line,int cursorPos) {
		Section[] sections = line.moveToNewLine(cursorPos,true);
		
		// create the new line
		Line newLine = new Line(_env,-1,this);
		if(sections.length > 0) {
			for(int i = 0;i < sections.length;i++) {
				sections[i].setSectionLine(newLine);
				newLine.addSection(sections[i]);
			}
		}
		else {
			TextAttributes attributes = new TextAttributes();
			// is the last section of the prev line a TextSection?
			Section last = line.getLastSection();
			if(last instanceof TextSection) {
				// if so we want to use the attributes of that section for our new one
				TextSection ts = (TextSection)last;
				attributes = ts.getAttributes();
			}
			
			// add new section in the line
			TextSection newSec = new TextSection(_env,"",cursorPos,newLine,
					this,attributes);
			newLine.addSection(newSec);
		}
		
		_lines.addAfter(line,newLine);
		
		Section s = newLine.getFirstSection();
		
		return (ContentSection)s;
	}
	
	/**
	 * @return the number of lines
	 */
	public int getLineCount() {
		return _lines.size();
	}
	
	/**
	 * NOTE: this has to loop through all lines. So use this method carefully!
	 * 
	 * @return the total number of sections in this environment
	 */
	public int getSectionCount() {
		int total = 0;
		int len = _lines.size();
		for(int i = 0;i < len;i++) {
			Line l = (Line)_lines.get(i);
			total += l.getSectionCount();
		}
		
		return total;
	}
	
	/**
	 * @return the first line in this paragraph
	 */
	public Line getFirstLine() {
		return (Line)_lines.getFirst();
	}
	
	/**
	 * @return the last line in this paragraph
	 */
	public Line getLastLine() {
		return (Line)_lines.getLast();
	}
	
	/**
	 * @return the first section in this environment
	 */	
	public Section getFirstSection() {
		Line l = (Line)_lines.getFirst();
		return l.getFirstSection();
	}
	
	/**
	 * @return the last section in this environment
	 */
	public Section getLastSection() {
		Line l = (Line)_lines.getLast();
		return l.getLastSection();
	}
	
	/**
	 * @return the linked list with all lines
	 */
	public MyLinkedList getLines() {
		return _lines;
	}
	
	/**
	 * returns the section at given cursor-position
	 * 
	 * @param cursorPos the cursor-position
	 * @return the Section-object
	 * @throws InvalidTextPositionException if the position is invalid
	 */
	public ContentSection getSectionAt(int cursorPos) throws InvalidTextPositionException {
		if(cursorPos < 0)
			throw new InvalidTextPositionException(cursorPos);
		
		// is this ane environment-paragraph?
		if(_containsEnv)
			return ((Environment)getFirstSection()).getSectionAt(cursorPos);
		
		Line line = getLineAtPosition(cursorPos);
		if(line != null)
			return getSectionAt(line,cursorPos);
		
		throw new InvalidTextPositionException(cursorPos);
	}
	
	/**
	 * returns the section at given cursor-position
	 * assumes that the cursor-position is in the given line
	 * 
	 * @param line the line the cursor-position belongs to
	 * @param cursorPos the cursor-position
	 * @return the Section-object
	 * @throws InvalidTextPositionException if the position is invalid
	 */
	public ContentSection getSectionAt(Line line,int cursorPos) throws InvalidTextPositionException {
		if(cursorPos < 0)
			throw new InvalidTextPositionException(cursorPos);
		
		return line.getSectionAt(cursorPos);
	}
	
	/**
	 * @return true if this paragraph is empty
	 */
	public boolean isEmpty() {
		if(_lines.size() > 1)
			return false;
		
		Section first = getFirstSection();
		return first != null && first.getElementLength() == 0;
	}
	
	/**
	 * @param index the index of the line
	 * @return the Line with given index or null if not found
	 */
	public Line getLine(int index) {
		if(index < 0 || index >= _lines.size())
				return null;
		
		return (Line)_lines.get(index);
	}
	
	/**
	 * inserts an environment in this paragraph. Due to a paragraph can't contain more
	 * content than one environment all of the current content will be removed and the 
	 * environment will be inserted.
	 * 
	 * @param env the Environment
	 */
	void insertEnvironment(Environment env) {
		// ensure that this paragraph is empty
		if(!isEmpty())
			clear();

		// ensure that the alignment is left in environment-paragraphs
		setHorizontalAlignment(ParagraphAttributes.ALIGN_LEFT);
		
		// insert into the first line
		int envLen = env.getElementLength();
		Line first = (Line)_lines.getFirst();
		env.setSectionLine(first);
		env.setSectionParagraph(this);
		env.setElementPos(0,envLen - 1);
		first.addSection(env);
		
		_containsEnv = true;
	}
	
	/**
	 * adds a new image section at given position
	 * 
	 * @param position the position where you want to insert the smiley
	 * @param img the image of the image-section
	 * @return the new section of the cursor
	 */
	ContentSection addImageSectionAt(int position,SecImage img) {
		Line line = getLineAtPosition(position);
		return addImageSectionAt(line,position,img);
	}
	
	/**
	 * adds a new image section at given position
	 * assumes that the given position is in the given line
	 * 
	 * @param line the line of the position
	 * @param position the position where you want to insert the smiley
	 * @param img the image of the image-section
	 * @return the new section of the cursor
	 */
	ContentSection addImageSectionAt(Line line,int position,SecImage img) {
		ContentSection sec = line.addImageSectionAt(position,img);
		
		adjustLines((Line)line.getNext(),1);
		increaseElementEndPos(1);
		
		line.getView().forceRefresh(ILineView.TAB_WIDTH);
		
		return sec;
	}
	
	/**
	 * adds the given text at the given position to the corresponding line
	 * 
	 * @param text the text to add
	 * @param position the position where to add the text (in this paragraph)
	 * @return the section where the text has been added
	 */
	ContentSection addTextAt(String text,int position) {
		return addTextAt(text,position,null);
	}
	
	/**
	 * adds the given text at the given position to the corresponding line
	 * 
	 * @param text the text to add
	 * @param position the position where to add the text (in this paragraph)
	 * @param attributes the attributes of the text to add
	 * @return the section where the text has been added
	 */
	ContentSection addTextAt(String text,int position,TextAttributes attributes) {
		Line l = getLineAtPosition(position);
		return addTextAt(text,l,position,attributes);
	}
	
	/**
	 * adds the given text at the given position to the corresponding line
	 * 
	 * @param text the text to add
	 * @param line the line of the given position
	 * @param position the position where to add the text (in this paragraph)
	 * @param attributes the attributes of the text to add
	 * @return the section where the text has been added
	 */
	ContentSection addTextAt(String text,Line line,int position,TextAttributes attributes) {
		ContentSection s = line.addTextAt(text,position,attributes);
		
		adjustLines((Line)line.getNext(),text.length());
		increaseElementEndPos(text.length());
		
		line.getView().forceRefresh(ILineView.TAB_WIDTH);
		
		return s;
	}
	
	/**
	 * performs word-wrap in this paragraph
	 * 
	 * @return the number of performed word-wraps
	 */
	int performWordWrap() {
		IWordWrap strategie = _env.getWordWrapStrategie();
		int wordWraps = 0;

		// at first we have to look if we can move something back to the previous line
		// because the user may have inserted a space (or another char) which would
		// cause the wordwrap-strategie to wrap at another position
		Line prev = (Line)_lines.getFirst();
		Line l = (Line)prev.getNext();
		if(l != null) {
			while(true) {
				int missing = strategie.getCharsToMove(prev,l);
				if(missing > 0) {
					// move the text to the previous line
					addToPrevLine(l,l.getLineStartPosition() + missing);
					wordWraps++;
					
					// remove empty virtual lines
					if(l.getLineLength() == 0) {
						_lines.remove(l);
						// we have to recalculate all paint-positions if we have removed a line
						getTextField().getPaintPosManager().markAllDirty();
					}
					else
						l.getView().forceRefresh(ILineView.TAB_WIDTH);
					
					prev.getView().forceRefresh(ILineView.TAB_WIDTH);
				}
				
				prev = (Line)prev.getNext();
				if(prev == null)
					break;
				
				l = (Line)l.getNext();
				if(l == null)
					break;
			}
		}
		
		// no we insert word-wraps if the line is too long
		ContentSection sec;
		l = (Line)_lines.getFirst();
		int breakPos = strategie.getBreakPosition(l);
		do {
			if(breakPos > 0) {
				// add to next virtual line?
				Line nextLine = (Line)l.getNext();
				if(nextLine != null)
					sec = addToNextLine(l,l.getLineStartPosition() + breakPos);
				else
					sec = moveToNextLine(l,l.getLineStartPosition() + breakPos);
				
				wordWraps++;
				l = sec.getSectionLine();

				// we have to refresh the view here
				l.getView().forceRefresh(ILineView.TAB_WIDTH);
				
				breakPos = strategie.getBreakPosition(l);
			}
			
			if(breakPos <= 0) {
				l = (Line)l.getNext();
				if(l == null)
					break;
				breakPos = strategie.getBreakPosition(l);
			}
		} while(true);
		
		return wordWraps;
	}
	
	/**
	 * deletes the line with given index
	 * adjusts the positions of all following lines
	 * 
	 * @param index the line-index
	 */
	void remove(int index) {
		Line l = getLine(index);
		if(l != null)
			remove(l);
	}
	
	/**
	 * removes the given line from the container
	 * adjusts the positions of the following lines
	 * 
	 * @param l the line to remove
	 */
	void remove(Line l) {
		_lines.remove(l);
		
		adjustLines((Line)l.getNext(),-(l.getLineLength() + 1));
	}
	
	/**
	 * removes the text between the start- and end-position in the given
	 * line and adjusts all positions of the following lines
	 * 
	 * @param l the line
	 * @param start the start-position
	 * @param end the end-position
	 * @return the number of removed characters
	 */
	int removeText(int start,int end) {
		if(_containsEnv) {
			Environment es = (Environment)getFirstSection();
			int c = es.removeText(start,end);
			
			return c;
		}
		
		int count = 0;
		Line l = getLineAtPosition(start);
		do {
			int lineEnd = l.getLineEndPosition();
			
			if(start <= lineEnd + 1 && end >= l.getLineStartPosition()) {
				int lCount = l.removeText(start,end);
				
				// remove the line?
				if(l.getLineLength() == 0 && !l.isFirst() && end >= lineEnd)
					_lines.remove(l);
				else if(count > 0)
					l.adjustPositions(l.getFirstSection(),-count);
				
				count += lCount;
			}
			
			if(end <= lineEnd + 1)
				break;
			
			l = (Line)l.getNext();
		} while(l != null);
		
		// adjust the following lines
		if(l != null)
			adjustLines((Line)l.getNext(),-count);
		
		return count;
	}
	
	/**
	 * adjusts the positions from the given line to the last line
	 * 
	 * @param start the start-line
	 * @param amount the amount to add
	 */
	private void adjustLines(Line start,int amount) {
		if(amount != 0) {
			while(start != null) {
				start.adjustPositions(0,amount);
				start = (Line)start.getNext();
			}
		}
	}
	
	/**
	 * determines the line which contains the given position
	 * 
	 * @param position the position to search for
	 * @return the line (may NOT be null!)
	 */
	public Line getLineAtPosition(int position) {
		Line first = (Line)_lines.get(0);
		if(position <= first.getLastCursorPos())
			return first;
		
		// the lines are sorted, so we can use binarySearch :)
		int index = _lines.getIndexBinarySearch(new Integer(position),new Comparator() {
			public int compare(Object arg0,Object arg1) {
				if(arg0 instanceof Line && arg1 instanceof Integer) {
					int pos = ((Integer)arg1).intValue();
					Line l = (Line)arg0;
					if(pos < l.getLineStartPosition())
						return 1;
					
					if(pos > l.getLastCursorPos())
						return -1;
				}
				
				return 0;
			}
		});
		
		if(index >= 0)
			return (Line)_lines.get(index);
		
		// return the last line
		return (Line)_lines.get(_lines.size() - 1);
	}
	
	public String toString() {
		StringBuffer buf = new StringBuffer();
		buf.append("$$ Paragraph: [S:" + _startPos + ",E:" + _endPos + ",L:" + _length);
		buf.append(",LC: " + getLineCount() + ",H:" + getParagraphView().getHeight());
		buf.append(",A:" + ParagraphAttributes.getAlignmentName(_align) + "]\n");
		int len = _lines.size();
		for(int i = 0;i < len;i++)
			buf.append(_lines.get(i) + "\n");
		buf.append("$$\n");

		return buf.toString();
	}
}